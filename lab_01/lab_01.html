<!DOCTYPE html>
 <!-- It's the HTML5 standard. -->
 
 <html>
     <head>
         <title>Lab 1 - Jakub Worek</title>
         <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
 
         <!-- The following meta line optimizes the site for mobile devices. 
		 It sets the viewport size to the screen size, so it will be displayed maximized, but unscaled. -->
         <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1">
         <style type="text/css">
             body {
                 /* Set the background color of the HTML page to black */
                 background-color: #000000;
 
                 /* Hide oversized content. This prevents the scroll bars. */
                 overflow: hidden;
             }
         </style>
         <!-- Include Three.js library -->
         <script src="three.js"></script>
     </head>
     <body>
         <!-- This is the DIV element which will contain the WebGL canvas. To be identifiable later on, the id 'WebGLCanvas' is applied to it. -->
         <div id="WebGLCanvas"> </div>
 
         <!-- This JavaScript block encloses the Three.js commands -->
        <script>
             // Global scene object
             var scene;
 
             // Global camera object
             var camera;

            // global renderer object for choinka
            var liscie1Mesh;
            var liscie2Mesh;
            var liscie3Mesh;
            var korzenMesh;

            // Global renderer object for domek
            var scianyMesh;
            var dachMesh;
            var drzwiMesh;
            var oknoMesh;
            var kominMesh;

            // Global renderer object for pojazd
            var vehicleBodyMesh, wheel1Mesh, wheel2Mesh;
            var vehicleSpeed = 0.02;

            // Global renderer object for tree
            var treeMeshes = [];
            var trunkMesh;
 
            // Initialize the scene
            initializeScene();
 
             // Render the scene (map the 3D world to the 2D scene)
            renderScene();
 
            // animate the scene
            animateScene();

             /**
              * Initialize the scene.
              */
            function initializeScene(){

                renderer = new THREE.WebGLRenderer({antialias:true});

                 // Set the background color of the renderer to black, with full opacity
                renderer.setClearColor(0x000000, 1);
 
                 // Get the size of the inner window (content area) to create a full size renderer
                canvasWidth = window.innerWidth;
                canvasHeight = window.innerHeight;
 
                 // Set the renderers size to the content areas size
                renderer.setSize(canvasWidth, canvasHeight);
 
                 // Get the DIV element from the HTML document by its ID and append the renderers DOM
                 // object to it
                document.getElementById("WebGLCanvas").appendChild(renderer.domElement);
 
                 // Create the scene, in which all objects are stored (e. g. camera, lights,
                 // geometries, ...)
                scene = new THREE.Scene();
 
                 // Define camera and add it to the scene.
                camera = new THREE.PerspectiveCamera(45, canvasWidth / canvasHeight, 1, 100);
                camera.position.set(0, 5, 15);
                camera.lookAt(scene.position);
                scene.add(camera);

                 // Create the triangle (or any arbitrary geometry).
                var triangleGeometry = new THREE.Geometry();
                triangleGeometry.vertices.push(new THREE.Vector3( 0.0,  1.0, 0.0));
                triangleGeometry.vertices.push(new THREE.Vector3(-1.0, -1.0, 0.0));
                triangleGeometry.vertices.push(new THREE.Vector3( 1.0, -1.0, 0.0));
                triangleGeometry.faces.push(new THREE.Face3(0, 1, 2));
 
                 // To color the surface, a material has to be created.
                 // We use MeshBasicMaterial				 
                 // from which we need in this example only 'color'.
 
                 // Create a white basic material and activate the 'doubleSided' attribute to force the
                 // rendering of both sides of each face (front and back). This prevents the so called
                 // 'backface culling'. Usually, only the side is rendered, whose normal vector points
                 // towards the camera. The other side is not rendered (backface culling). But this
                 // performance optimization sometimes leads to wholes in the surface. When this happens
                 // in your surface, simply set 'doubleSided' to 'true'.
                var triangleMaterial = new THREE.MeshBasicMaterial({
                    color:0xfcba03,
                    side:THREE.DoubleSide
                });
 
                 // Create a mesh and insert the geometry and the material. Translate the whole mesh
                 // by -1.5 on the x axis and by 4 on the z axis. Finally add the mesh to the scene.
                var triangleMesh = new THREE.Mesh(triangleGeometry, triangleMaterial);
                triangleMesh.position.set(-1.5, 0.0, 4.0);
                scene.add(triangleMesh);
 
                 // The creation of the square is done in the same way as the triangle.
                 // 1. Instantiate the geometry object
                 // 2. Add the vertices
                 // 3. Define the faces by setting the vertices indices
                var squareGeometry = new THREE.Geometry();
                squareGeometry.vertices.push(new THREE.Vector3(-1.0,  1.0, 1.0));
                squareGeometry.vertices.push(new THREE.Vector3( 1.0,  1.0, 1.0));
                squareGeometry.vertices.push(new THREE.Vector3( 1.0, -1.0, 1.0));
                squareGeometry.vertices.push(new THREE.Vector3(-1.0, -1.0, 1.0));
                //squareGeometry.faces.push(new THREE.Face4(0, 1, 2, 3));         //No more Face4 in Three.js
                squareGeometry.faces.push(new THREE.Face3(0, 1, 2));
                squareGeometry.faces.push(new THREE.Face3(0, 2, 3));
 
                 // Create a white basic material and activate the 'Doubleside' attribute 
				 // (alternatives are: 'FrontSide' and 'BackSide')
                var squareMaterial = new THREE.MeshBasicMaterial({
                    color:0x52fc03,
                    side:THREE.DoubleSide
                });
 
                 // Create a mesh and insert the geometry and the material. Translate the whole mesh
                 // by 1.5 on the x axis and by 4 on the z axis and add the mesh to the scene.
                var squareMesh = new THREE.Mesh(squareGeometry, squareMaterial);
                squareMesh.position.set(1.5, 0.0, 4.0);
                scene.add(squareMesh);


                 // choinka
                var liscie = new THREE.Geometry();
                liscie.vertices.push(new THREE.Vector3( 0.0,  1.0, 0.0));
                liscie.vertices.push(new THREE.Vector3(-1.0, -1.0, 0.0));
                liscie.vertices.push(new THREE.Vector3( 1.0, -1.0, 0.0));

                liscie.faces.push(new THREE.Face3(0, 1, 2));

                var liscieMaterial = new THREE.MeshBasicMaterial({
                    color:0x00ff00,
                    side:THREE.DoubleSide
                });

                liscie1Mesh = new THREE.Mesh(liscie, liscieMaterial);
                liscie1Mesh.position.set(0, 0.0, -4.0);
                scene.add(liscie1Mesh);

                liscie2Mesh = new THREE.Mesh(liscie, liscieMaterial);
                liscie2Mesh.position.set(0, 0.5, -4.0);
                scene.add(liscie2Mesh);

                liscie3Mesh = new THREE.Mesh(liscie, liscieMaterial);
                liscie3Mesh.position.set(0, 1.0, -4.0);
                scene.add(liscie3Mesh);

                var korzen = new THREE.Geometry();
                korzen.vertices.push(new THREE.Vector3(-0.3,  0.0, 0.0));
                korzen.vertices.push(new THREE.Vector3( 0.3,  0.0, 0.0));
                korzen.vertices.push(new THREE.Vector3( 0.3, -0.5, 0.0));
                korzen.vertices.push(new THREE.Vector3(-0.3, -0.5, 0.0));

                korzen.faces.push(new THREE.Face3(0, 1, 2));
                korzen.faces.push(new THREE.Face3(0, 2, 3));

                var korzenMaterial = new THREE.MeshBasicMaterial({
                    color:0x8b4513,
                    side:THREE.DoubleSide
                });

                korzenMesh = new THREE.Mesh(korzen, korzenMaterial);
                korzenMesh.position.set(0, -1.0, -4.0);
                scene.add(korzenMesh);

                // domek

                var sciany = new THREE.Geometry();
                sciany.vertices.push(new THREE.Vector3(-1.0,  1.0, 1.0));
                sciany.vertices.push(new THREE.Vector3( 1.0,  1.0, 1.0));
                sciany.vertices.push(new THREE.Vector3( 1.0, -1.0, 1.0));
                sciany.vertices.push(new THREE.Vector3(-1.0, -1.0, 1.0));

                sciany.faces.push(new THREE.Face3(0, 1, 2));
                sciany.faces.push(new THREE.Face3(0, 2, 3));
                
                var scianyMaterial = new THREE.MeshBasicMaterial({
                    color:0xf6ff00,
                    side:THREE.DoubleSide
                });

                scianyMesh = new THREE.Mesh(sciany, scianyMaterial);
                scianyMesh.position.set(-5, 0.0, 4.0);
                scene.add(scianyMesh);

                var dach = new THREE.Geometry();
                dach.vertices.push(new THREE.Vector3(-1.0,  1.0, 1.0));
                dach.vertices.push(new THREE.Vector3( 1.0,  1.0, 1.0));
                dach.vertices.push(new THREE.Vector3( 0.0,  2.5, 1.0));
                dach.faces.push(new THREE.Face3(0, 1, 2));

                var dachMaterial = new THREE.MeshBasicMaterial({
                    color:0xb31d1d,
                    side:THREE.DoubleSide
                });

                dachMesh = new THREE.Mesh(dach, dachMaterial);
                dachMesh.position.set(-5, 0.0, 4.0);
                scene.add(dachMesh);

                var drzwi = new THREE.Geometry();
                drzwi.vertices.push(new THREE.Vector3(-0.3,  0.7, 1.0));
                drzwi.vertices.push(new THREE.Vector3( 0.3,  0.7, 1.0));
                drzwi.vertices.push(new THREE.Vector3( 0.3, -1.0, 1.0));
                drzwi.vertices.push(new THREE.Vector3(-0.3, -1.0, 1.0));

                drzwi.faces.push(new THREE.Face3(0, 1, 2));
                drzwi.faces.push(new THREE.Face3(0, 2, 3));

                var drzwiMaterial = new THREE.MeshBasicMaterial({
                    color:0x9c652a,
                    side:THREE.DoubleSide
                });

                drzwiMesh = new THREE.Mesh(drzwi, drzwiMaterial);
                drzwiMesh.position.set(-5.3, 0.0, 4.1);
                scene.add(drzwiMesh);

                var okno = new THREE.Geometry();
                okno.vertices.push(new THREE.Vector3(-0.3,  0.0, 1.0));
                okno.vertices.push(new THREE.Vector3( 0.3,  0.0, 1.0));
                okno.vertices.push(new THREE.Vector3( 0.3, -0.7, 1.0));
                okno.vertices.push(new THREE.Vector3(-0.3, -0.7, 1.0));

                okno.faces.push(new THREE.Face3(0, 1, 2));
                okno.faces.push(new THREE.Face3(0, 2, 3));

                var oknoMaterial = new THREE.MeshBasicMaterial({
                    color:0x2a8b9c,
                    side:THREE.DoubleSide
                });

                oknoMesh = new THREE.Mesh(okno, oknoMaterial);
                oknoMesh.position.set(-4.5, 0.7, 4.1);
                scene.add(oknoMesh);

                var komin = new THREE.Geometry();
                komin.vertices.push(new THREE.Vector3(-0.15,  0.0, 1.0));
                komin.vertices.push(new THREE.Vector3( 0.15,  0.0, 1.0));
                komin.vertices.push(new THREE.Vector3( 0.15,  0.7, 1.0));
                komin.vertices.push(new THREE.Vector3(-0.15,  0.7, 1.0));

                komin.faces.push(new THREE.Face3(0, 1, 2));
                komin.faces.push(new THREE.Face3(0, 2, 3));

                var kominMaterial = new THREE.MeshBasicMaterial({
                    color:0xd14f17,
                    side:THREE.DoubleSide
                });

                kominMesh = new THREE.Mesh(komin, kominMaterial);
                kominMesh.position.set(-4.4, 1.2, 3.9);
                scene.add(kominMesh);

                // pojazd
                // --- Vehicle Body (Rectangle) ---
                var vehicleBodyGeometry = new THREE.Geometry();
                vehicleBodyGeometry.vertices.push(new THREE.Vector3(-1.0,  0.5, 0.0));
                vehicleBodyGeometry.vertices.push(new THREE.Vector3( 1.0,  0.5, 0.0));
                vehicleBodyGeometry.vertices.push(new THREE.Vector3( 1.0, -0.5, 0.0));
                vehicleBodyGeometry.vertices.push(new THREE.Vector3(-1.0, -0.5, 0.0));
                vehicleBodyGeometry.faces.push(new THREE.Face3(0, 1, 2));
                vehicleBodyGeometry.faces.push(new THREE.Face3(0, 2, 3));

                var vehicleBodyMaterial = new THREE.MeshBasicMaterial({
                    color: 0x91827c,
                    side: THREE.DoubleSide
                });

                vehicleBodyMesh = new THREE.Mesh(vehicleBodyGeometry, vehicleBodyMaterial);
                vehicleBodyMesh.position.set(0, -1.5, 0); // Place the vehicle on the ground
                scene.add(vehicleBodyMesh);

                // --- Wheels (Circles) ---
                var wheelGeometry = new THREE.CircleGeometry(0.3, 32); // Radius = 0.3, 32 segments
                var wheelMaterial = new THREE.MeshBasicMaterial({ color: 0x363534 });

                wheel1Mesh = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel2Mesh = new THREE.Mesh(wheelGeometry, wheelMaterial);

                // Position the wheels relative to the body
                wheel1Mesh.position.set(-0.7, -2, 0.01); // Left wheel
                wheel2Mesh.position.set(0.7, -2, 0.01);  // Right wheel

                scene.add(wheel1Mesh);
                scene.add(wheel2Mesh);

                // choinka ale to stożki
                // Tworzenie pnia choinki (sześcian)
                var trunkGeometry = new THREE.BoxGeometry(1, 2, 1);
                var trunkMaterial = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
                trunkMesh = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunkMesh.position.set(7, -2, 0); // Umieszczamy pień niżej
                scene.add(trunkMesh);

                // Tworzenie warstw choinki (stożki)
                var coneMaterial = new THREE.MeshBasicMaterial({ color: 0x008000 });
                var heights = [3, 2.5, 2]; // Wysokości warstw choinki
                var radii = [3, 2.5, 2];   // Promienie podstaw warstw
                var yOffset = 1;          // Początkowa pozycja Y dla choinki

                for (var i = 0; i < heights.length; i++) {
                    var coneGeometry = new THREE.ConeGeometry(radii[i], heights[i], 32);
                    var coneMesh = new THREE.Mesh(coneGeometry, coneMaterial);
                    coneMesh.position.set(7, yOffset, 0); // Ustawienie pozycji stożka
                    scene.add(coneMesh);
                    treeMeshes.push(coneMesh);
                    yOffset += heights[i] / 2; // Przesuwanie kolejnych stożków w górę
                }

            }
            function animateScene(){
                // At first, we increase the y rotation of the triangle mesh and decrease the x
                // rotation of the square mesh.
            
                // Increase the y rotation of the triangle
                liscie1Mesh.rotation.y += 0.1;
                liscie2Mesh.rotation.y += 0.1;
                liscie3Mesh.rotation.y += 0.1;
                korzenMesh.rotation.y += 0.1;

                vehicleBodyMesh.position.x += vehicleSpeed;
                wheel1Mesh.position.x += vehicleSpeed;
                wheel2Mesh.position.x += vehicleSpeed;

                // Reset position if it moves off the screen
                if (vehicleBodyMesh.position.x > 6.4) {
                    vehicleBodyMesh.position.x = -7;
                    wheel1Mesh.position.x = -7 - 0.7;
                    wheel2Mesh.position.x = -7 + 0.7;
                }

                // Define the function, which is called by the browser supported timer loop. If the
                // browser tab is not visible, the animation is paused. So 'animateScene()' is called
                // in a browser controlled loop.
                requestAnimationFrame(animateScene);

                // Map the 3D scene down to the 2D screen (render the frame)
                renderScene();
            }

            /**
             * Render the scene. Map the 3D world to the 2D screen.
             */
            function renderScene(){
                renderer.render(scene, camera);
            }
         </script>
     </body>
</html>